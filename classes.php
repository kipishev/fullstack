<?php
ini_set('display_errors', 1); // или можно указать значение true вместо 1
/*--------------------------------- ООП (Родительские классы) */
/* В ООП используются классы. ООП и классы позволяют структурировать код.
Классы хранят внутри себя данные и действия, которые можно выполнить над этими данными.
Функции внутри классов являются методами. Все методы по умолчанию публичны с точки зрения области видимости.
Классы стоит рассматривать как некий чертеж, по которому можно создать что-то реальное (объект) и не один раз.
То, что создается на основе класса называется экземпляром класса или объектом класса.

Есть служебный метод __construct, который никогда не вызывается вручную,
а вызывается всегда автоматически в момент создания экземпляра класса. Данный метод не должен внутри себя
ничего выводить, он должен получить какие-либо данные, обработать их и добавить в свои свойства. Данные
внутри класса называются свойствами. Свойства, как и методы, необходимо заранее описывать.

После определения свойств, их нужно указать для метода __construct как ожидаемые входящие параметры,
которые будут передаваться при создании экземпляра класса. Это в случае если свойства у нас не заполнены.

При создании каждого экземпляра нашего класса вызывается конструктор, который из передаваемых пользователем
данных заполняет совйства класса, после чего мы можем их использовать внутри наших объявленных методов.
Обращение к свойствам происходит через $this->название метода без знака доллора.

$this используется для доступа к свойствам и методам внутри класса. При создании экземпляра класса, $this
обращается к передаваемым параметрам этого создаваемого экземпляра класса.

Поскольку все свойства в нашем примере публичные, мы можем их просматривать вне классов и соответственно
переопределять. Поэтому свойства внутри классов редко бывают публичными.

Помимо публичной видимости свойствам можно назначать еще видимость зущищенную (protected) или
приватную (private). Protected - свойства видны внутри классов где они определены и внутри дочерних классов.
Private - свойства видны тольк внутри классов, в которых они определены.

Методы также могут быть публичными, защищенными и приватными.
*/

class Car { // Создание класса
    protected $brand; // Определение свойства
    protected $model;
    protected $year;
    protected $mileage;
    private $noAccess;

    public function __construct($b, $m, $y, $mileage = 0) {
        //echo '!<br>'; // Проверка того, что метод отрабатывает автоматически
        $this->brand = $b; // Заполнение параметров
        $this->model = $m;
        $this->year = $y;
        $this->mileage = $mileage;
        $this->noAccess = true;
    }

    public function drive() {
        echo "$this->brand $this->model ($this->year, $this->mileage) driving<br>";
    }

    public function addMileage($mileage) {
        /* Добовляем метод, который бы мог позволить изменять защищенное свойство класса с пробегом,
        увеличиваем пробег. */
        $error = false;
        if ($mileage > 0) {
            $this->mileage += $mileage;
        } else {
            $error = true;
        }
        return [
            'error' => $error,
            'mileage' => $this->mileage,
        ];
    }

    private function showNoAccess() {
        echo $this->noAccess;
    }

}

$audi = new Car('Audi', 'Q5', 2021); // Создание экземпляра класса (их может быть сколько угодно)
$vesta = new Car('Lada', 'Vesta', 2020, 15000);

// $vesta->year = 2016; // Можем поменять значение свойства если бы оно было публичным, иначе получаем ошибку

$audi->drive(); // Вызов метода из объекта
$vesta->drive();

$currentAudiMileage = $audi->addMileage(2000); // Покатались на audi
echo $currentAudiMileage['mileage'] . '<br>';

echo '<hr>'; /*--------------------------------- */
$res = $vesta->addMileage(-10000);
if ($res['error']) {
    echo "Не удалось увеличить пробег <br>";
} else {
    echo "Пробег увеличен. Текущий пробег: {$res['mileage']} <br>";
}

$audi->drive(); // Увеличили текущий пробег audi
$vesta->drive();

echo '<hr>'; /*--------------------------------- */
$res = $vesta->addMileage(1000);
if ($res['error']) {
    echo "Не удалось увеличить пробег <br>";
} else {
    echo "Пробег увеличен. Текущий пробег: {$res['mileage']} <br>";
}

$audi->drive(); // Увеличили текущий пробег audi
$vesta->drive();

/*--------------------------------- ООП (Свойствов 1: наследование (дочерние классы) */
/* При создании экземпляра дочернего класса, если мы хотим чтобы все свойства были заполнены,
их также необходимо передавать и для этого в дочернем классе также нужен метод-конструктор для их обработки.
Метод-конструктор необходимо объявлять с теми же параметрами, с которыми данный метод объявлен в
родительском классе.

При этом мы будем заполнять не свойства дочернего класса, а свойства родительского класса через дочерний класс.

Метод-конструктор вызывается автоматически при создании экземпляра родительского класса. Но при создании
экземпляра дочернего класса, метод-конструктор родительского класса не вызывается автоматически, его нужно
вызвать вручную.

Дочерний класс забирает все свойства родительского класса, но при этом он также может иметь собственные свойства.
В этом и состоит идея использования дочерних классов (избежать дублирования кода).
*/
/*--------------------------------- ООП (Свойство: полиморфиз) */
/* Мы можем переопределить методы в родительском классе. Не смотря на то, что в родительском классе есть
метод drive, такой же метод мы можем объявить в дочернем классе.
В PHP нельзя в одном классе объявить несколько методов с одинаковым названием.
*/
/*--------------------------------- ООП (Свойство 3: инкапсуляция) */
/* В одном классе мы собираем и методы и свойства и еще модификаторы доступа (в одной капсуле несколько
возможностей) */
/*--------------------------------- ООП (Модификаторы доступа) */
/*
*/

class ElectroCar extends Car {
    public $electrocar; // Свойство дочернего класса

    public function __construct($b, $m, $y, $mileage = 0) { // Вызывается автоматически
        $this->electrocar = true; // Просто укажем, что такое свойство есть (дальше можем делать, например, проверку на наличие данного совойства)
        parent::__construct($b, $m, $y, $mileage); // Вручную вызываем конструктор родительского класса
    }
    public function drive() { // Переопределяем метод (полиморфиз)
        echo "Electrocar $this->brand $this->model ($this->year, $this->mileage) driving<br>";
    }
    public function parentDrive() { // Перезаписали метод, но вызвали в итоге метод родительского класса
        parent::drive();
    }

}
echo '<hr>'; /*--------------------------------- */
$tesla = new ElectroCar('Tesla', 'Model S', 2021); // Создаем объект дочернего класса
$tesla->drive(); // Данный метод не описан в дочернем классе, но он наследуется от родительского
$tesla->parentDrive();
$tesla->showNoAccess(); // Обращение к приватному свойству из дочернего класса вызовет ошибку























