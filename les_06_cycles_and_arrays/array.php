<?php
echo '<h3>LESSON 05</h3>';
/*--------------------------------- Массивы */
$numbers = [1, 2, 3, 4, 5]; // определение массива
echo $numbers[0]; // вывести значение элемента, индекс которого равен 0
echo $numbers[15]; // вывод будет равен NULL

echo '<pre>';
print_r($numbers);

// Чтобы вывести элементы массива в циклах WHILE или FOR, нам необходимо знать длину массива
$count = count($numbers);
echo $count . '<br>';

/* Зная длину массива мы теперь можем вывести все его элементы (последний элемент в массиве - это всегда
count() - 1) */
for ($i=0; $i < $count; $i++) {
    echo "$i $numbers[$i]<br>"; // выводим и индекс и итый элемент
}

/*--------------------------------- Специальная функция FOREACH */
/* Не нужно указывать никакого условия, условием окончания цикла будет просто последний элемент,
т. е. нам не нужно знать длину массива */
echo '<hr>';
foreach ($numbers as $number) {
    echo "$number <br>";
}
// каждому эелементу массива соответствует ключ и значение
echo '<br>';
foreach ($numbers as $key => $value) {
    echo "$key: $value <br>";
}

// можно определить пустой массив и затем заполнить его значениями
$new_numbers = [];
for ($i = 0; $i < 10; $i++) {
    $new_numbers[] = $i + 1;
/* Конструкция для добавления вовой записи в массив - обращение к пустому элементу.
Новый элемент добавляется в конец массива. Ключи массива при этом создаются автоматически. */
}
// Можно добавить элемент массива явно указав его ключ, чтобы PHP его не создавал автоматически
/* Мы можем также добавить новый элемент в массив и если его не было, то он просто добавится,
если был, то заменится. */
$new_numbers[3] = 99;
$new_numbers[10] = 100;
$new_numbers[67] = 67 * 67; // числовые индексы могут идти не по порядку

echo '<pre>';
print_r($new_numbers);

// Пример не числового (ассоциативного) массива
echo '<br>';
$person = [
    'name' => 'Andrei',
    'age' => 36,
    'city' => 'Moscow',
    'language' => 'Russian'
];
$person['car'] = true;
$person['language'] = 'Russian, Italian, English';
echo '<pre>';
print_r($person);

// Значение элемента массива можно затереть, но ключ не куда не денется
// Чтобы удалить пару ключ - значение, можно использовать специальную функцию

$person['name'] = '';
echo '<pre>';
print_r($person);

unset($person['name']);
echo '<pre>';
print_r($person);

echo '<hr>';
echo '<h3>LESSON 06</h3>';
/*--------------------------------- Модификация массивов */
// Можно массив преобразовав в строку
$colors = ['red', 'green', 'blue']; // как из массива сделать строку?
$output = ''; // первое, что нам нужно сделать - это объявить пустую строку, чтобы потом к ней приращивать значения
foreach ($colors as $color) {
    $output = $output . ' ' . $color;
}
echo $output; // получаем стрку с пробелом в самом начале
echo '<br>';

echo trim($output);
echo '<br>';
// функция, которая убирает пробелы и слева и справа (не важно сколько пробелов)

$string_colors = implode(', ', $colors);
// данная функция позволяет выводить элементы массивав в виде строки с заданными разделителями
// точка с запятой часто используется если эти значения нужно потом загрузить в Excel
echo "$string_colors<br>";

// Есть и обратная функция explode, которая из строки сздает массив
$new_str = 'Предложение из 4х слов';
$array = explode(' ', $new_str);
print_r($array);

/*--------------------------------- Сортировка массивов (функции сортировки) */
echo '<br>';
$numbers = [2, 4, 6, 1, 3];
print_r($numbers);

/* sort - сортировка массива по его значениям,
при этом порядок ключей остаются как был (значения ключенй менятся).
Если массив ассоциативный, то функцией sort воспользоваться не удастся (сбрасываются все ключи) */
sort($numbers);
print_r($numbers);

/* asort - сортировка ассоциативных массивов */
print_r($person);
asort($person);
print_r($person);

/* ksort - сортировка по ключам */
ksort($person);
print_r($person);

/*--------------------------------- Для всех этих функций есть функции,
которые сортируют в обратном порядке. Перед словом sort добавляем r (revers) */
rsort($numbers);
print_r($numbers);

arsort($person);
print_r($person);

krsort($person);
print_r($person);

echo '<hr>';
/*--------------------------------- Сортировка многомерных массивов */
$persons = [
    [
        'name' => 'Andrei',
        'age' => 36,
        'city' => 'London'
    ],
    [
        'name' => 'Ivan',
        'age' => 30,
        'city' => 'Moscow'
    ],
    [
        'name' => 'Petr',
        'age' => 25,
        'city' => 'Kazan'
    ],
];

print_r($persons);

function sortByAge ($a, $b) { // Определяем функцию
    if ($a['age'] > $b['age']) {
        return 1; // return используется только в функциях
    } elseif ($a['age'] < $b['age']) {
        return -1;
    } elseif ($a['age'] < $b['age']) {
        return 0;
    }
}

function sortByCity ($a, $b) {
    return $a['city'] <=> $b['city'];
    /*if ($a['city'] > $b['city']) {
        return 1;
    } elseif ($a['city'] < $b['city']) {
        return -1;
    } elseif ($a['city'] < $b['city']) {
        return 0;
    }*/
}

usort($persons, 'sortByCity');
/* Сортировать будем по какому-либо выбранному ключю каждого вложенного массива.
Первым параметром функция принимает сам массив; вторым параметром - функцию callback,
которую мы определили выше и используем теперь в функции usort */

print_r($persons);

/*--------------------------------- Оператор сравнения - космический корабль,
позволяет заменить конструкцию, которая должна возвращать 1, -1 или 0, одной строкой */
echo '<hr>';

$numberOne = 15;
$numberTwo = 15;

/*if ($numberOne > $numberTwo) {
    echo 1;
} elseif ($numberOne < $numberTwo) {
    echo -1;
} elseif ($numberOne < $numberTwo) {
    echo 0;
}*/

echo $numberOne <=> $numberTwo;
echo '<br>';
/* Оператор сравнения - космический корабль (возвращает три значения вместо 2х как другие операторы),
данный оператор может быть полезен, в основном, в функциях сортировки, большего применения автор не встречал */

/*--------------------------------- Другие примеры сортировки */
$names = array_column($persons, 'name');
/* Достаем из многомерного массива значения только по одному ключу каждого из вложенных массивов */
print_r($names);
array_multisort($names, SORT_DESC, $persons);
/* Сортируем многомерный массив по полученным ранее значениям первых ключей каждого из вложенных массивов */
print_r($persons);

/*--------------------------------- Достаем только все ключи из одного массива */
$keys = array_keys($person);
print_r($keys);

/*--------------------------------- Достаем только все значения из одного массива */
$values = array_values($person);
print_r($values);

/*--------------------------------- Обращения к элементам вложенных массивов */
array_multisort($names, SORT_ASC, $persons);
print_r($persons[0]); // в этой записи мы получили массив
print_r($persons[0]['name']); // в этой записи мы получили значение вложенного массива
echo '<br>';
print_r($persons[0]['name'][0]); /* не смотря на то, что у нас больше нет вложенных массивов,
 данная запись буде обращаться тогда уже к первому элементу строки,
 воспринимая его как первый элемент следующего вложенного массива*/

















